package templates

import (
	"fmt"
	"strings"
	"github.com/wadahiro/fedlens/internal/ui/templates/components"
)

// JWKSKeyData holds structured display data for a single JWKS key.
type JWKSKeyData struct {
	Rows []components.SignatureRow
}

// OIDCResultEntryData holds display data for a single result entry.
type OIDCResultEntryData struct {
	ID                 string // "result-0", "result-1", ...
	Type               string // "Login", "Refresh", "Re-auth: <name>", "Logout", "Error"
	Timestamp          string // Full format: "2006/01/02 15:04:05 MST"
	SidebarTimestamp   string // Short format: "01/02 15:04:05"
	Subject            string
	IDTokenClaims      []components.ClaimRow
	IDTokenSigRows     []components.SignatureRow
	AccessTokenClaims  []components.ClaimRow
	AccessTokenSigRows []components.SignatureRow
	UserInfoClaims     []components.ClaimRow
	UserInfoErrorRows  []components.ErrorRow
	AuthRequestURL     string
	AuthRequestParams  []components.ClaimRow
	AuthResponseRaw    string
	AuthResponseParams []components.ClaimRow
	AuthResponseHeader string // "HTTP/1.1 302 Found\nLocation: https://..."
	TokenRequestURL       string
	TokenRequestParams    []components.ClaimRow
	TokenRequestRaw       string // URL-encoded POST body (key=value&...)
	UserInfoRequestURL    string
	UserInfoRequestParams []components.ClaimRow
	// Token Response display
	TokenResponseStatusLine string
	TokenResponseHeaders    string
	TokenResponseBody       string
	TokenResponseBodyLang   string // "json", "markup", ""
	TokenResponseConnError  string // connection error message (cleaned)
	// UserInfo Response display
	UserInfoResponseStatusLine string
	UserInfoResponseHeaders    string
	UserInfoResponseBody       string
	UserInfoResponseBodyLang   string // "json", "markup", ""
	UserInfoResponseConnError  string // connection error message (cleaned)
	// Raw Tokens
	IDTokenRaw           string
	IDTokenHeader        string
	IDTokenPayload       string
	IDTokenSignature     string
	AccessTokenJWT       string
	AccessTokenHeader    string
	AccessTokenPayload   string
	AccessTokenSignature string
	AccessTokenRaw       string
	RefreshTokenJWT       string
	RefreshTokenHeader    string
	RefreshTokenPayload   string
	RefreshTokenSignature string
	RefreshTokenRaw       string
	SigVerifiedAll     bool
	SidebarLabel       string
	SidebarDot         string // "login", "refresh", "reauth", "logout", "error"
	Children           []Section // sidebar sub-sections
	// Error fields
	ErrorStatus      string // HTTP status code (e.g. "400")
	ErrorCode        string
	ErrorDescription string
	ErrorURI         string
	ErrorDetail      string
	// Logout fields
	LogoutRequestURL         string
	LogoutRequestParams      []components.ClaimRow
	LogoutIDTokenRaw         string
	LogoutIDTokenHeader      string
	LogoutIDTokenPayload     string
	LogoutIDTokenSignature   string
}

// OIDCPageData holds all data for the OIDC page.
type OIDCPageData struct {
	Name            string
	Results         []OIDCResultEntryData // Reverse chronological
	HasRefreshToken bool
	CallbackPath    string
	// REFERENCE
	JWKSJSON      string
	DiscoveryJSON string
	EndpointRows  []components.ClaimRow
	JWKSKeys      []JWKSKeyData
}

templ OIDCIndex(page PageInfo, data OIDCPageData) {
	@Layout("OIDC - " + data.Name, page) {
		<!-- Action Bar -->
		@oidcActionBar(page)
		<!-- Results Timeline -->
		if len(data.Results) > 0 {
			<h2 class="body-section-heading">Results</h2>
			<div class="results-timeline">
				for i, entry := range data.Results {
					@OIDCResultEntry(i, entry)
				}
			</div>
		}
		<!-- REFERENCE -->
		<h2 class="body-section-heading">Reference</h2>
		@components.Collapsible("sec-flow", "Flow Diagram", true) {
			@components.OIDCSequence(data.CallbackPath)
		}
		@components.Collapsible("sec-provider", "OpenID Provider", true) {
			if len(data.EndpointRows) > 0 {
				@components.KeyValueTable("op-endpoints", "Endpoints", "Name", "URL", data.EndpointRows)
			}
			for i, key := range data.JWKSKeys {
				@components.SignatureTable(fmt.Sprintf("Public Key #%d", i+1), key.Rows)
			}
			@components.CodeBlock("JWKS (Raw)", data.JWKSJSON)
			if data.DiscoveryJSON != "" {
				@components.CodeBlock("Discovery Metadata", data.DiscoveryJSON)
			} else {
				<article>
					<header>Discovery Metadata</header>
					<p class="not-configured">Not configured</p>
				</article>
			}
		}
	}
}

templ oidcActionBar(page PageInfo) {
	if page.LoginURL != "" || page.LogoutURL != "" || page.RefreshURL != "" || page.UserInfoURL != "" || len(page.ReauthItems) > 0 {
		<div class="action-bar">
			if page.LoginURL != "" {
				<a href={ templ.SafeURL(page.LoginURL) } role="button" class="action-btn" data-testid="login-btn">Login</a>
			}
			if page.UserInfoURL != "" {
				<a href={ templ.SafeURL(page.UserInfoURL) } role="button" class="secondary outline action-btn" data-testid="userinfo-btn">UserInfo</a>
			}
			if page.RefreshURL != "" {
				<a href={ templ.SafeURL(page.RefreshURL) } role="button" class="secondary outline action-btn" data-testid="refresh-btn">Refresh Token</a>
			}
			if len(page.ReauthItems) > 0 {
				if len(page.ReauthItems) == 1 {
					<a href={ templ.SafeURL(page.ReauthItems[0].URL) } role="button" class="secondary outline action-btn" data-testid="reauth-btn">{ page.ReauthItems[0].Label }</a>
				} else {
					<a href={ templ.SafeURL(page.ReauthItems[0].URL) } role="button" class="secondary outline action-btn" data-testid="reauth-btn">{ page.ReauthItems[0].Label }</a>
					<div class="dropdown">
						<button class="secondary outline action-btn" onclick="toggleDropdown(this)" data-testid="reauth-more-btn">
							More &#9662;
						</button>
						<div class="dropdown-menu">
							for i, item := range page.ReauthItems[1:] {
								<a href={ templ.SafeURL(item.URL) } class="dropdown-item" data-testid={ fmt.Sprintf("reauth-%d", i) }>{ item.Label }</a>
							}
						</div>
					</div>
				}
			}
			if page.LogoutURL != "" {
				<a href={ templ.SafeURL(page.LogoutURL) } role="button" class="outline action-btn" data-testid="logout-btn">Logout</a>
			}
		</div>
	}
}

func resultBadgeClass(entryType string) string {
	switch {
	case entryType == "Login":
		return "result-login"
	case entryType == "Refresh":
		return "result-refresh"
	case entryType == "UserInfo":
		return "result-refresh"
	case strings.HasPrefix(entryType, "Logout"):
		return "result-logout"
	case strings.HasPrefix(entryType, "Error"):
		return "result-error"
	default: // Re-auth: *
		return "result-reauth"
	}
}

func resultBadgeLabel(entryType string) string {
	return entryType
}

func oidcErrorRows(entry OIDCResultEntryData) []components.ErrorRow {
	var rows []components.ErrorRow
	if entry.ErrorStatus != "" {
		rows = append(rows, components.ErrorRow{Label: "status", Value: entry.ErrorStatus})
	}
	if entry.ErrorCode != "" {
		rows = append(rows, components.ErrorRow{Label: "error", Value: entry.ErrorCode})
	}
	if entry.ErrorDescription != "" {
		rows = append(rows, components.ErrorRow{Label: "error_description", Value: entry.ErrorDescription})
	}
	if entry.ErrorURI != "" {
		rows = append(rows, components.ErrorRow{Label: "error_uri", Value: entry.ErrorURI})
	}
	if entry.ErrorDetail != "" {
		rows = append(rows, components.ErrorRow{Label: "detail", Value: entry.ErrorDetail})
	}
	return rows
}

templ OIDCResultEntry(index int, entry OIDCResultEntryData) {
	if index == 0 {
		<details id={ entry.ID } class={ "result-entry", resultBadgeClass(entry.Type) } open>
			<summary>
				<span class="result-timestamp">{ entry.Timestamp }</span>
				<kbd class={ resultBadgeClass(entry.Type) }>{ resultBadgeLabel(entry.Type) }</kbd>
				if strings.HasPrefix(entry.Type, "Error") && entry.ErrorCode != "" {
					{ entry.ErrorCode }
				}
			</summary>
			@resultEntryContent(entry)
		</details>
	} else {
		<details id={ entry.ID } class={ "result-entry", resultBadgeClass(entry.Type) }>
			<summary>
				<span class="result-timestamp">{ entry.Timestamp }</span>
				<kbd class={ resultBadgeClass(entry.Type) }>{ resultBadgeLabel(entry.Type) }</kbd>
				if strings.HasPrefix(entry.Type, "Error") && entry.ErrorCode != "" {
					{ entry.ErrorCode }
				}
			</summary>
			@resultEntryContent(entry)
		</details>
	}
}

templ resultEntryContent(entry OIDCResultEntryData) {
	if strings.HasPrefix(entry.Type, "Error") {
		@errorEntryContent(entry)
	} else if strings.HasPrefix(entry.Type, "Logout") {
		@logoutEntryContent(entry)
	} else {
		@normalEntryContent(entry)
	}
}

templ errorEntryContent(entry OIDCResultEntryData) {
	<!-- Error Details -->
	if len(oidcErrorRows(entry)) > 0 {
		<details id={ entry.ID + "-error" } class="result-subsection" open>
			<summary>Error Details</summary>
			@components.ErrorTable(oidcErrorRows(entry))
		</details>
	}
	<!-- Protocol Messages -->
	if entry.AuthRequestURL != "" || entry.TokenRequestURL != "" || entry.UserInfoRequestURL != "" {
		<details id={ entry.ID + "-protocol" } class="result-subsection">
			<summary>Protocol Messages</summary>
			@oidcProtocolMessages(entry)
		</details>
	}
}

templ logoutEntryContent(entry OIDCResultEntryData) {
	if entry.LogoutIDTokenHeader != "" {
		<details id={ entry.ID + "-details" } class="result-subsection" open>
			<summary>Logout Details</summary>
			@components.TokenBlock("id_token_hint", entry.LogoutIDTokenHeader, entry.LogoutIDTokenPayload, entry.LogoutIDTokenSignature, entry.LogoutIDTokenRaw)
		</details>
	}
	if entry.LogoutRequestURL != "" {
		<details id={ entry.ID + "-protocol" } class="result-subsection" open>
			<summary>Protocol Messages</summary>
			if len(entry.LogoutRequestParams) > 0 {
				@components.ParamsTable("End Session Request (GET)", entry.LogoutRequestParams, "GET " + entry.LogoutRequestURL)
			} else {
				@components.CodeBlock("End Session Request (GET)", entry.LogoutRequestURL)
			}
		</details>
	}
}

templ normalEntryContent(entry OIDCResultEntryData) {
	<!-- Identity & Claims -->
	if len(entry.IDTokenClaims) > 0 || len(entry.UserInfoClaims) > 0 {
		<details id={ entry.ID + "-claims" } class="result-subsection" open>
			<summary>Identity & Claims</summary>
			if entry.Subject != "" {
				@components.SubjectTable("Subject (sub)", entry.Subject)
			}
			if len(entry.IDTokenClaims) > 0 {
				@components.ClaimsTable(entry.ID + "-id-token-claims", "ID Token Claims", entry.IDTokenClaims)
			}
			if len(entry.AccessTokenClaims) > 0 {
				@components.ClaimsTable(entry.ID + "-access-token-claims", "Access Token Claims", entry.AccessTokenClaims)
			}
			if len(entry.UserInfoClaims) > 0 {
				@components.ClaimsTable(entry.ID + "-userinfo-claims", "UserInfo Claims", entry.UserInfoClaims)
			}
			if len(entry.UserInfoErrorRows) > 0 {
				<h4>UserInfo Error</h4>
				@components.ErrorTable(entry.UserInfoErrorRows)
			}
		</details>
	}
	<!-- Signature Verification -->
	if len(entry.IDTokenSigRows) > 0 || len(entry.AccessTokenSigRows) > 0 {
		<details id={ entry.ID + "-sigs" } class="result-subsection">
			<summary>
				Signature Verification
				if entry.SigVerifiedAll {
					<span class="verification-badge verified">Verified</span>
				} else {
					<span class="verification-badge not-verified">Unverified</span>
				}
			</summary>
			if len(entry.IDTokenSigRows) > 0 {
				@components.SignatureTable("ID Token Signature Verification", entry.IDTokenSigRows)
			}
			if len(entry.AccessTokenSigRows) > 0 {
				@components.SignatureTable("Access Token Signature Verification", entry.AccessTokenSigRows)
			}
		</details>
	}
	<!-- Protocol Messages -->
	if entry.AuthRequestURL != "" || entry.TokenRequestURL != "" || entry.UserInfoRequestURL != "" {
		<details id={ entry.ID + "-protocol" } class="result-subsection">
			<summary>Protocol Messages</summary>
			@oidcProtocolMessages(entry)
		</details>
	}
	<!-- Raw Tokens -->
	if entry.Type != "UserInfo" && (entry.IDTokenHeader != "" || entry.AccessTokenHeader != "" || entry.AccessTokenRaw != "" || entry.RefreshTokenHeader != "" || entry.RefreshTokenRaw != "") {
		<details id={ entry.ID + "-tokens" } class="result-subsection">
			<summary>Raw Tokens</summary>
			if entry.IDTokenHeader != "" {
				@components.TokenBlock("ID Token (JWT)", entry.IDTokenHeader, entry.IDTokenPayload, entry.IDTokenSignature, entry.IDTokenRaw)
			}
			if entry.AccessTokenHeader != "" {
				@components.TokenBlock("Access Token (JWT)", entry.AccessTokenHeader, entry.AccessTokenPayload, entry.AccessTokenSignature, entry.AccessTokenJWT)
			} else if entry.AccessTokenRaw != "" {
				@components.PlainCodeBlock("Access Token (Opaque)", entry.AccessTokenRaw)
			}
			if entry.RefreshTokenHeader != "" {
				@components.TokenBlock("Refresh Token (JWT)", entry.RefreshTokenHeader, entry.RefreshTokenPayload, entry.RefreshTokenSignature, entry.RefreshTokenJWT)
			} else if entry.RefreshTokenRaw != "" {
				@components.PlainCodeBlock("Refresh Token (Opaque)", entry.RefreshTokenRaw)
			}
		</details>
	}
}

templ oidcProtocolMessages(entry OIDCResultEntryData) {
	// Authentication Request
	if len(entry.AuthRequestParams) > 0 {
		@components.ParamsTable("Authentication Request (GET)", entry.AuthRequestParams, "GET " + entry.AuthRequestURL)
	} else if entry.AuthRequestURL != "" {
		@components.CodeBlock("Authentication Request (GET)", entry.AuthRequestURL)
	}
	// Authentication Response
	if len(entry.AuthResponseParams) > 0 {
		@components.ParamsTable("Authentication Response", entry.AuthResponseParams, entry.AuthResponseHeader)
	} else if entry.AuthResponseRaw != "" {
		@components.CodeBlock("Authentication Response", entry.AuthResponseRaw)
	}
	// Token Request
	if len(entry.TokenRequestParams) > 0 {
		@components.HTTPRequestBlock("Token Request (POST)", "POST " + entry.TokenRequestURL, entry.TokenRequestParams, entry.TokenRequestRaw)
	}
	// Token Response
	if entry.TokenResponseStatusLine != "" {
		@components.HTTPResponseBlock("Token Response", entry.TokenResponseStatusLine, entry.TokenResponseHeaders, entry.TokenResponseBody, entry.TokenResponseBodyLang)
	} else if entry.TokenResponseConnError != "" {
		@components.HTTPConnErrorBlock("Token Response", entry.TokenResponseConnError)
	}
	// UserInfo Request
	if entry.UserInfoRequestURL != "" {
		@components.HTTPRequestBlock("UserInfo Request (GET)", entry.UserInfoRequestURL, nil, "")
	}
	// UserInfo Response
	if entry.UserInfoResponseStatusLine != "" {
		@components.HTTPResponseBlock("UserInfo Response", entry.UserInfoResponseStatusLine, entry.UserInfoResponseHeaders, entry.UserInfoResponseBody, entry.UserInfoResponseBodyLang)
	} else if entry.UserInfoResponseConnError != "" {
		@components.HTTPConnErrorBlock("UserInfo Response", entry.UserInfoResponseConnError)
	}
}
